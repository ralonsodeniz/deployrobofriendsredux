{"version":3,"sources":["components/Card.js","components/CardList.js","components/SearchBox.js","components/Scroll.js","components/ErrorBoundary.js","components/CounterButton.js","components/Header.js","actions.js","api/api.js","constants.js","containers/App.js","serviceWorker.js","reducers.js","index.js"],"names":["Card","_ref","name","email","id","react_default","a","createElement","className","src","concat","alt","CardList","robots","map","user","userIndex","components_Card","key","SearchBox","searchChange","type","placeholder","onChange","Scroll","props","style","overflowY","border","height","children","ErrorBoundary","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","hasError","error","info","setState","Component","CounterButton","updateCount","count","nextProps","nextState","color","onClick","Header","components_CounterButton","requestRobots","dispatch","link","fetch","then","response","json","data","payload","catch","App","onRequestRobots","_this$props","searchField","onSearchChange","isPending","filteredRobots","filter","robot","toLowerCase","includes","components_Header","components_SearchBox","components_Scroll","components_ErrorBoundary","components_CardList","connect","searchRobots","event","target","value","Boolean","window","location","hostname","match","initialStateSearch","initialStateRobots","logger","createLogger","rootReducer","combineReducers","arguments","length","undefined","action","assign","store","createStore","applyMiddleware","thunkMiddleware","ReactDOM","render","es","src_containers_App","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.5b3e61d0.chunk.js","sourcesContent":["import React from \"react\"; //even if it seems we are not using react, we are, all the virtual dom is referring to react elements to draw in the html dom\n\nconst Card = ({ name, email, id }) => {\n  return (\n    <div className=\"tc bg-light-green dib br3 ma2 grow bw2 shadow-5\">\n      <div>\n        <img src={`https://robohash.org/${id}?set=set4`} alt=\"robots\" />\n      </div>\n      <div>\n        <h2>{name}</h2>\n        <p>{email}</p>\n      </div>\n    </div>\n  );\n};\nexport default Card;\n","import React from \"react\";\nimport Card from \"./Card\";\n\nconst CardList = ({ robots }) => {\n  return (\n    <div>\n      {robots.map((user, userIndex) => {\n        return (\n          <Card\n            key={robots[userIndex].id}\n            id={robots[userIndex].id}\n            name={robots[userIndex].name}\n            email={robots[userIndex].email}\n          />\n        );\n      })}\n    </div>\n  );\n};\nexport default CardList;\n","import React from \"react\";\n\nconst SearchBox = ({ searchChange }) => {\n  return (\n    <div className=\"pa2\">\n      <input\n        className=\"tc pa3 ba b--green bg-lightest-blue\"\n        type=\"search\"\n        placeholder=\"search Robots...\"\n        onChange={searchChange}\n      />\n    </div>\n  );\n};\n\nexport default SearchBox;\n","import React from \"react\";\n\nconst Scroll = props => {\n  return (\n    <div\n      style={{\n        overflowY: \"scroll\",\n        border: \"1px solid black\",\n        height: \"500px\"\n      }}\n    >\n      {props.children}\n    </div>\n  );\n};\n\nexport default Scroll;\n","import React, { Component } from \"react\";\n\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hasError: false\n    };\n  }\n\n  componentDidCatch(error, info) {\n    this.setState({ hasError: true });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1>Ooooops. That is not good</h1>;\n    }\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n","import React, { Component } from \"react\";\r\n\r\nclass CounterButton extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      // this module has its own state and it not uses redux since its state only affects it\r\n      count: 0\r\n    };\r\n  }\r\n  shouldComponentUpdate(nextProps, nextState) {\r\n    if (this.state.count !== nextState.count) {\r\n      // if the new count value is different from the previous one we have stored then we want to render this component\r\n      return true;\r\n    }\r\n    return false; // if it is not we don't\r\n  }\r\n\r\n  updateCount = () => {\r\n    // remember that setState is an async function so when we want to operate an state with itself we should do it this way so we are sure that we catch the actual value of the state\r\n    this.setState(state => {\r\n      return { count: state.count + 1 };\r\n    });\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <button color={this.props.color} onClick={this.updateCount}>\r\n        Count: {this.state.count}\r\n      </button>\r\n    );\r\n  }\r\n}\r\n\r\nexport default CounterButton;\r\n","// we create this component to avoid unnecesary reload of the header\r\nimport React, { Component } from \"react\";\r\nimport CounterButton from \"./CounterButton\";\r\n\r\nclass Header extends Component {\r\n  shouldComponentUpdate(nextProps, nextState) {\r\n    // we are going to use this lyfecyle method to avoid header to be reloaded when it is not needed\r\n    // if this returns true, the component will be updated, if it returns false it won't\r\n    // this method receives nextProps and nextState in case we want to use it to determine if we want to update or not\r\n    // those two values give us the new values of state and props after an event that triggers the update so we can decide if we do want to update the component\r\n    return false; // in our case we don't want it to be rendered more than the initial time\r\n  }\r\n  render() {\r\n    return (\r\n      <div>\r\n        <h1 className=\"f1\">RoboFriends</h1>\r\n        <CounterButton color=\"red\" />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Header;\r\n","// in this document we create the redux actions | actions are functions that passes objects\nimport {\n  CHANGE_SEARCHFIELD,\n  REQUEST_ROBOTS_PENDING,\n  REQUEST_ROBOTS_SUCCESS,\n  REQUEST_ROBOTS_FAILED\n} from \"./constants\";\nimport { apiCall } from \"./api/api\";\n// actions always have a type of action, which is a constant and a payload, what the action takes\n// export const setSearchField = text => ({\n//   // this is the action for the SearchField component\n//   // it will take text, what the user inputs and is goign to return an object\n//   type: CHANGE_SEARCHFIELD, // this is the action, the search field change | this is a constant thats why its in uppercase, and to make sure we don't misspell it we will create actual constants in a different file to assign to the types of the actions\n//   payload: text // payload is a common term in redux, in this case we are sending the data which is needed\n// }); // wraping the curly brackets inside parentesis directly states that we are returning what it is inside the curly brackets\n\nexport const setSearchField = text => ({\n  type: CHANGE_SEARCHFIELD,\n  payload: text\n});\n\nexport const requestRobots = () => dispatch => {\n  // considering how the function is triggered in App.js this is a currying function, first dispatch is executed and it returns a function which is executed with the dispatch parameter returned from the first execution\n  // in the async action we have dispatch as parameter, it will be passed when we\n  dispatch({ type: REQUEST_ROBOTS_PENDING }); // firs we dispatch the action to inform the promise is being processed\n  apiCall(\"https://jsonplaceholder.typicode.com/users\") // then we start fetching\n    // once we have the response we have 2 options\n    .then(data => dispatch({ type: REQUEST_ROBOTS_SUCCESS, payload: data })) // the promise is resolved satisfactorily\n    .catch(error => dispatch({ type: REQUEST_ROBOTS_FAILED, payload: error })); // the promise is rejected\n};\n","export const apiCall = link => fetch(link).then(response => response.json());\n","// this is the file where we store the constants with their respective string inside for the type of the redux actions\nexport const CHANGE_SEARCHFIELD = \"CHANGE_SEARCHFIELD\";\n// we need 3 consts for the request robots since it is a promise, and we have the pending status, while the promise is being processed, the success status, when is done and everything is ok and lastly, the failed when something goes wrong\nexport const REQUEST_ROBOTS_PENDING = \"REQUEST_ROBOTS_PENDING\";\nexport const REQUEST_ROBOTS_SUCCESS = \"REQUEST_ROBOTS_SUCCESS\";\nexport const REQUEST_ROBOTS_FAILED = \"REQUEST_ROBOTS_FAILED\";\n// this is more o like standar with all synchronous actions like AJAX calls\n","import React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport CardList from \"../components/CardList\";\nimport SearchBox from \"../components/SearchBox\";\nimport Scroll from \"../components/Scroll\";\nimport ErrorBoundary from \"../components/ErrorBoundary\";\nimport Header from \"../components/Header\";\nimport \"./App.css\";\nimport { setSearchField, requestRobots } from \"../actions\";\n\nconst mapStateToProps = state => {\n  // this function is used to pass the state to props for App, what do I need to listen from state and pass it to props\n  // we are stating that searchField is going to be taken from state, from the reducer we used in the store props we created in index.js and then the property of state we want\n  return {\n    // we return an object\n    searchField: state.searchRobots.searchField,\n    robots: state.requestRobots.robots,\n    isPending: state.requestRobots.isPending,\n    error: state.requestRobots.error\n  };\n};\nconst mapDispatchToProps = dispatch => {\n  // it says what props I should listen to that are actions that I need to get dispatched\n  // dispatch is what triggers the action\n  return {\n    // here we also return an object\n    onSearchChange: event => dispatch(setSearchField(event.target.value)), // onSearchChange is just the name of the props that is going to be receive, we are keeping the one we had previous to redux\n    onRequestRobots: () => dispatch(requestRobots()) // in this case, we dispatch a function, not an object with the dipatch method in it\n  };\n};\n\nclass App extends Component {\n  componentDidMount() {\n    this.props.onRequestRobots();\n  }\n\n  render() {\n    const { searchField, onSearchChange, robots, isPending } = this.props;\n    const filteredRobots = robots.filter(robot => {\n      return robot.name.toLowerCase().includes(searchField.toLowerCase());\n    });\n    return isPending ? (\n      <h1 className=\"f1 tc\">roboFriends list is Loading...</h1>\n    ) : (\n      <div className=\"tc\">\n        <Header />\n        <SearchBox searchChange={onSearchChange} />\n        <Scroll>\n          <ErrorBoundary>\n            <CardList robots={filteredRobots} />\n          </ErrorBoundary>\n        </Scroll>\n      </div>\n    );\n  }\n}\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(App); //connect is a higher order function, is a function that returns another function\n//  if we realize the syntax is very similar tu currying functions where we had a function that we executed in different steps first with some variables and then with others\n//  connect runs a first time and returns another function that is going to be runned using App as a parameter\n//  connect accepts 2 parameters, mapStateToProps and mapDispatchToProps\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","// in this file we create the reducers\nimport {\n  CHANGE_SEARCHFIELD,\n  REQUEST_ROBOTS_PENDING,\n  REQUEST_ROBOTS_SUCCESS,\n  REQUEST_ROBOTS_FAILED\n} from \"./constants\";\n// first thing we have to create is a initial state of the app\nconst initialStateSearch = {\n  // we need to have an initial state from which our application start\n  searchField: \"\"\n};\n\n// now we create the reducer, that is a function\nexport const searchRobots = (state = initialStateSearch, action = {}) => {\n  // the third principle says that changes using pure function, this is a pure function that returns always the same for the same inputs\n  // state parameter is the state of the application and action is the action that is related with this reducer | we are giving them initial states so we don't get errors if nothing is passed\n  // the reducer gets the state and the action and when they receive and action related with the searchRobots they do something\n  switch (action.type) {\n    case CHANGE_SEARCHFIELD:\n      return Object.assign({}, state, { searchField: action.payload });\n    // according to the 3 principles of redux, the second one states that the state is read only, so we do not modify state so we use Object.assign to create a new object which is returned\n    // this new object is a copy of state to whom we add what we receive from the action\n    // the synxtax, {} is the target object, in this case an empty one\n    // state is the first object we assign to the new one\n    // {searchField:action.payload} is the second object we assign, updating what state had in that property\n    // there is another way to do this using object destructuring and spread operator\n    // return { ...state, searchField: action.payload };\n    // this means that we are returning a new object which is form by state and updated with the second parameter\n    default:\n      return state; // a pure function allways has to return something by default, in the case of reducers the default state\n  }\n};\n\nconst initialStateRobots = {\n  // we create a new initial state for the reducer of requestRobots since it does not care of the same states as searchRobots\n  isPending: false,\n  robots: [],\n  error: \"\"\n};\n\nexport const requestRobots = (state = initialStateRobots, action = {}) => {\n  switch (action.type) {\n    case REQUEST_ROBOTS_PENDING:\n      return Object.assign({}, state, { isPending: true });\n    case REQUEST_ROBOTS_SUCCESS:\n      return Object.assign({}, state, {\n        robots: action.payload,\n        isPending: false\n      });\n    case REQUEST_ROBOTS_FAILED:\n      return Object.assign({}, state, {\n        error: action.payload,\n        isPending: false\n      });\n    default:\n      return state;\n  }\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { createStore, applyMiddleware, combineReducers } from \"redux\"; // we need to create the Store \\ applyMiddleware is needed to insert middleware in our app\n// combineReducers is a function from redux that allows us to combine multiple reducers in order to have just one to create the store\nimport { Provider } from \"react-redux\";\nimport { createLogger } from \"redux-logger\"; // this is the middleware for loggin\nimport thunkMiddleware from \"redux-thunk\"; // this is the middleware for async actions in redux\n// the store is the first principle of redux, the one source of all true, the big js object that stores the state of all our app\nimport \"./index.css\";\nimport App from \"./containers/App\";\n// standar says that components have to be capitalized\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"tachyons\";\nimport { searchRobots, requestRobots } from \"./reducers\";\n\nconst logger = createLogger();\nconst rootReducer = combineReducers({ searchRobots, requestRobots });\nconst store = createStore(\n  rootReducer,\n  applyMiddleware(thunkMiddleware, logger)\n); // with this we create the store\n// as a second parameter we set what middleware want to use, logger has to be the last middleware always\n// in real life we have a lot of reducers so we need to have one rootReducer that combines all of the reducers of the app\n// now we have to pass the store to our app\n// to do this, and in order to not to have to pass it all the time from App to App childs we use the Provider component that comes in react-redux\n// Provider is a wrap component, as it was ErrorBoundary for example, that allows the access to the store to all the components and subcomponents wrapped inside it\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n// to install redux we do npm install redux\n// npm install react-redux to connect react with redux store\n// first thing to do is to creat an action and a reducer\n// connect makes the function of store.subscribe, which is to let know the components that need the store the link to it and listen to it\n// connect simplifies a lot the procedure\n// middleware is something in between the action and the reducer that may modify the action before getting to the reducer or trigger another action\n// its somehow similar to the middleware in expressjs\n// redux logger is a middleware that allows us to log redux actions\n// in order to handle async actions with redux we use another middleware called redux-think\n// this middleware will manage async actions such fetching an api\n// usually the actions returns objects, but not the async actions, they return a function. And there is when thunk enters in action.\n// thunk is listening when an action returns a function and catches it, in order to treat it and make redux able to understand it since redux only understand actions that are objects\n"],"sourceRoot":""}